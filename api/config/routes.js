'use strict';

module.exports = {
    agent: require('../modules/agent/config/agent.route'),
    domain: require('../modules/domain/config/domain.route'),
    intent: require('../modules/intent/config/intent.route'),
    entity: require('../modules/entity/config/entity.route'),
    context: require('../modules/context/config/context.route')
    
 One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
One of Code Climate’s primary focuses is to provide insight and visibility into how your codebase is changing over time. After we analyze a new commit, we’ll share our findings with you in various ways.

Progress Events
Your repository’s Progress page is the main hub for you to review Code Climate’s analysis data.

When any of the following events occur during an analysis of your default branch, we’ll update your Progress report:

An area of your codebase has its grade increase or decrease from one letter grade to another.

New code is added to your codebase. The Progress report will show you its initial grade.

Test coverage improves or declines.

We’ll also post a weekly summary to your Progress report (on Monday), which shows information like how many files were changed, inserted, and deleted in the past seven days.

The very first analysis that Code Climate runs on your repository (directly after the repository is added) will never result in any Progress report updates. Only the second and subsequent analyses can produce Progress report updates.
Email and Integration Events
We understand that you may not have time to check the Code Climate website every day, so we’ll also notify you via email and chatroom integrations. To reduce noise, we’re more conservative about when we send notifications.

Below are all possible notifications that can result from an analysis of your default branch:

An area of your codebase increases from a D or F to any other grade. For example, from a D to an A.

An area of your codebase decreases to a D or F from any other grade. For example, from a B to an F.

New code is added to your codebase and its initial grade is a D or F.

Test coverage improves or declines.

By default, emails for this event are disabled. You can enable them by editing your personal email preferences.
By default, you’ll receive one weekly summary per repository that has received at least one commit in the past week. Weekly summaries are sent only via email, not via integration notifications.
TABLE OF CONTENTS
Progress Events
Email and Integration Events
   
 
};


class AgentValidate {
    constructor() {

        this.findAll = {
            query: (() => {

                return {
                    start: Joi.number().description('The index of the first element to return. 0 is the default start.'),
                    limit: Joi.number().description('Number of elements to return from start. All the elements are returned by default')
                };
            })()
        };

        this.findById = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })()
        };

        this.findByName = {
            params: (() => {

                return {
                    agentName: AgentSchema.agentName.required().description('The name of the agent')
                };
            })()
        };

        this.findEntitiesByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    start: Joi.number().description('The index of the first element to return. 0 is the default start.'),
                    limit: Joi.number().description('Number of elements to return from start. All the elements are returned by default')
                };
            })()
        };

        this.findEntityByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    entityId: EntitySchema.id.required().description('Id of the entity')
                };
            })()
        };

        this.findDomainsByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    start: Joi.number().description('The index of the first element to return. 0 is the default start.'),
                    limit: Joi.number().description('Number of elements to return from start. All the elements are returned by default')
                };
            })()
        };

        this.findDomainByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    domainId: DomainSchema.id.required().description('Id of the domain')
                };
            })()
        };

        this.findIntentsInDomainByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    domainId: DomainSchema.id.required().description('Id of the domain')
                };
            })(),
            query: (() => {

                return {
                    start: Joi.number().description('The index of the first element to return. 0 is the default start.'),
                    limit: Joi.number().description('Number of elements to return from start. All the elements are returned by default')
                };
            })()
        };

        this.findIntentByIdInDomainByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    domainId: DomainSchema.id.required().description('Id of the domain'),
                    intentId: IntentSchema.id.required().description('Id of the intent')
                };
            })()
        };

        this.findIntentScenarioInDomainByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    domainId: DomainSchema.id.required().description('Id of the domain'),
                    intentId: IntentSchema.id.required().description('Id of the intent')
                };
            })()
        };

        this.findIntentWebhookInDomainByIdByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent'),
                    domainId: DomainSchema.id.required().description('Id of the domain'),
                    intentId: IntentSchema.id.required().description('Id of the intent')
                };
            })()
        };

        this.add = {
            payload: (() => {

                return {
                    agentName: AgentSchema.agentName.required(),
                    description: AgentSchema.description,
                    language: AgentSchema.language.valid('en', 'es', 'de', 'fr', 'pt').required().error(new Error('Please provide a valid language for the agent. Supported languages are: en, es, de, fr')),
                    timezone: AgentSchema.timezone.required(),
                    useWebhook: AgentSchema.useWebhook.required(),
                    domainClassifierThreshold: AgentSchema.domainClassifierThreshold.required(),
                    fallbackResponses: AgentSchema.fallbackResponses.required().min(1).error(new Error('please add at least one fallback response for the agent'))
                };
            })()
        };

        this.updateById = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            payload: (() => {

                return {
                    agentName: AgentSchema.agentName,
                    description: AgentSchema.description,
                    language: AgentSchema.language.valid('en', 'es', 'de', 'fr', 'pt').error(new Error('Please provide a valid language for the agent. Supported languages are: en, es, de, fr')),
                    timezone: AgentSchema.timezone,
                    useWebhook: AgentSchema.useWebhook,
                    domainClassifierThreshold: AgentSchema.domainClassifierThreshold,
                    fallbackResponses: AgentSchema.fallbackResponses.min(1).error(new Error('please add at least one fallback response for the agent'))
                };
            })()
        };

        this.deleteById = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })()
        };

        this.parse = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    text: Joi.string().required().description('Text to parse'),
                    timezone: Joi.string().description('Timezone for duckling parse. Default UTC')
                };
            })()
        };

        this.parsePost = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            payload: (() => {

                return {
                    text: Joi.string().required().description('Text to parse'),
                    timezone: Joi.string().description('Timezone for duckling parse. Default UTC')
                };
            })()
        };

        this.converse = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    sessionId: Joi.string().required().description('Id of the session'),
                    text: Joi.string().required().description('Text to parse'),
                    timezone: Joi.string().description('Timezone for duckling parse. Default UTC')
                };
            })()
        };

        this.conversePost = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            payload: (() => {

                return {
                    sessionId: Joi.string().required().description('Id of the session'),
                    text: Joi.string().required().description('Text to parse'),
                    timezone: Joi.string().description('Timezone for duckling parse. Default UTC')
                };
            })(),
            options: {
                allowUnknown: true
            }
        };

        this.export = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    withReferences: Joi.bool().default(true).description('Flag to indicate if method should exports ids and ancestors of an element')
                };
            })()
        };

        this.import = {
            payload: (() => {

                return {
                    agentName: AgentSchema.agentName.required(),
                    description: AgentSchema.description,
                    language: AgentSchema.language.required().valid('en', 'es', 'de', 'fr', 'pt').error(new Error('Please provide a valid language for the agent. Supported languages are: en, es, de, fr')),
                    timezone: AgentSchema.timezone.required(),
                    domainClassifierThreshold: AgentSchema.domainClassifierThreshold.required(),
                    fallbackResponses: AgentSchema.fallbackResponses.required(),
                    useWebhook: AgentSchema.useWebhook.required(),
                    webhook: {
                        webhookUrl: WebhookSchema.webhookUrl.required().error(new Error('The url is required. Please specify an url for the webhook.')),
                        webhookVerb: WebhookSchema.webhookVerb.valid('GET', 'PUT', 'POST', 'DELETE', 'PATCH').required().error(new Error('Please provide a valid verb for the webhook. Supported verbs are: GET, PUT, POST, DELETE, PATCH.')),
                        webhookPayloadType: WebhookSchema.webhookPayloadType.valid('None', 'JSON', 'XML').required().error(new Error('Please provide a valid payload type for the webhook. Supported types are: None, JSON, XML.')),
                        webhookPayload: WebhookSchema.webhookPayload.allow('').optional()
                    },
                    entities: Joi.array().items({
                        entityName: EntitySchema.entityName.required(),
                        uiColor: EntitySchema.uiColor,
                        examples: Joi.array().items({
                            value: ExampleSchema.value.required(),
                            synonyms: ExampleSchema.synonyms
                        }).required()
                    }),
                    domains: Joi.array().items({
                        domainName: DomainSchema.domainName.required(),
                        enabled: DomainSchema.enabled.required(),
                        intentThreshold: DomainSchema.intentThreshold.required(),
                        lastTraining: DomainSchema.lastTraining,
                        model: DomainSchema.model,
                        intents: Joi.array().items({
                            intentName: IntentSchema.intentName.required(),
                            examples: Joi.array().items({
                                userSays: IntentExampleSchema.userSays.required().error(new Error('The user says text is required')),
                                entities: Joi.array().items({
                                    start: IntentEntitySchema.start.required().error(new Error('The start value should be an integer and it is required.')),
                                    end: IntentEntitySchema.end.required().error(new Error('The end value should be an integer and it is required.')),
                                    value: IntentEntitySchema.value.required().error(new Error('The parsed value is required.')),
                                    entity: IntentEntitySchema.entity.required().error(new Error('The entity reference is required.'))
                                }).required().allow([])
                            }).required().min(2).error(new Error('Please specify at least two examples for your intent definition.')),
                            scenario: {
                                scenarioName: ScenarioSchema.scenarioName.required(),
                                slots: Joi.array().items({
                                    slotName: SlotSchema.slotName.required(),
                                    entity: SlotSchema.entity.required(),
                                    isList: SlotSchema.isList.required(),
                                    isRequired: SlotSchema.isRequired.required(),
                                    textPrompts: SlotSchema.textPrompts
                                }),
                                intentResponses: ScenarioSchema.intentResponses.required()
                            },
                            useWebhook: IntentSchema.useWebhook.required(),
                            webhook: {
                                webhookUrl: WebhookSchema.webhookUrl.required().error(new Error('The url is required. Please specify an url for the webhook.')),
                                webhookVerb: WebhookSchema.webhookVerb.valid('GET', 'PUT', 'POST', 'DELETE', 'PATCH').required().error(new Error('Please provide a valid verb for the webhook. Supported verbs are: GET, PUT, POST, DELETE, PATCH.')),
                                webhookPayloadType: WebhookSchema.webhookPayloadType.valid('None', 'JSON', 'XML').required().error(new Error('Please provide a valid payload type for the webhook. Supported types are: None, JSON, XML.')),
                                webhookPayload: WebhookSchema.webhookPayload.allow('').optional()
                            }
                        })
                    })
                };
            })()
        };

        this.findIntentsByAgentId = {
            params: (() => {

                return {
                    id: AgentSchema.id.required().description('Id of the agent')
                };
            })(),
            query: (() => {

                return {
                    start: Joi.number().description('The index of the first element to return. 0 is the default start.'),
                    limit: Joi.number().description('Number of elements to return from start. All the elements are returned by default')
                };
            })()
        };

        this.addWebhook = {
            params: (() => {

                return {
                    id: IntentSchema.id.required().description('Id of the intent')
                };
            })(),
            payload: (() => {

                return {
                    agent: ScenarioSchema.agent.required().error(new Error('The agent is required. Please specify an agent for the webhook.')),
                    webhookUrl: WebhookSchema.webhookUrl.required().error(new Error('The url is required. Please specify an url for the webhook.')),
                    webhookVerb: WebhookSchema.webhookVerb.valid('GET', 'PUT', 'POST', 'DELETE', 'PATCH').required().error(new Error('Please provide a valid verb for the webhook. Supported verbs are: GET, PUT, POST, DELETE, PATCH.')),
                    webhookPayloadType: WebhookSchema.webhookPayloadType.valid('None', 'JSON', 'XML').required().error(new Error('Please provide a valid payload type for the webhook. Supported types are: None, JSON, XML.')),
                    webhookPayload: WebhookSchema.webhookPayload.allow('').optional()
                };
            })()
        };

        this.findWebhook = {
            params: (() => {

                return {
                    id: IntentSchema.id.required().description('Id of the intent')
                };
            })()
        };

        this.updateWebhook = {
            params: (() => {

                return {
                    id: IntentSchema.id.required().description('Id of the intent')
                };
            })(),
            payload: (() => {

                return {
                    webhookUrl: WebhookSchema.webhookUrl,
                    webhookVerb: WebhookSchema.webhookVerb.valid('GET', 'PUT', 'POST', 'DELETE', 'PATCH').error(new Error('Please provide a valid verb for the webhook. Supported verbs are: GET, PUT, POST, DELETE, PATCH.')),
                    webhookPayloadType: WebhookSchema.webhookPayloadType.valid('None', 'JSON', 'XML').error(new Error('Please provide a valid payload type for the webhook. Supported types are: None, JSON, XML.')),
                    webhookPayload: WebhookSchema.webhookPayload.allow('').optional()
                };
            })()
        };

        this.deleteWebhook = {
            params: (() => {

                return {
                    id: IntentSchema.id.required().description('Id of the intent')
                };
            })()
        };
    }
}
